package main

import (
	"fmt"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strings"

	options "google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	httpPackage    = protogen.GoImportPath("net/http")
	jsonPackage    = protogen.GoImportPath("encoding/json")
	fmtPackage     = protogen.GoImportPath("fmt")

	generatedFilenameExtension = ".pb.rest.go"
	generatedPackageSuffix     = "rest"
)

func main() {
	protogen.Options{}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(
				pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL,
			)
			for _, file := range plugin.Files {
				if file.Generate {
					generate(plugin, file)
				}
			}
			return nil
		},
	)
}

func generate(plugin *protogen.Plugin, file *protogen.File) {
	file.GoPackageName += generatedPackageSuffix

	generatedFilenamePrefixToSlash := filepath.ToSlash(file.GeneratedFilenamePrefix)
	file.GeneratedFilenamePrefix = path.Join(
		path.Dir(generatedFilenamePrefixToSlash),
		string(file.GoPackageName),
		path.Base(generatedFilenamePrefixToSlash),
	)
	generatedFile := plugin.NewGeneratedFile(
		file.GeneratedFilenamePrefix+generatedFilenameExtension,
		protogen.GoImportPath(path.Join(
			string(file.GoImportPath),
			string(file.GoPackageName),
		)),
	)
	generatePreamble(generatedFile, file)
	for i, service := range file.Services {
		generateService(generatedFile, file, service, file.Proto.Service[i])
	}
}

func generatePreamble(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by ", filepath.Base(os.Args[0]), ". DO NOT EDIT")
	g.P("//")
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// Deprecated file")
	} else {
		g.P("// Source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
}

func generateService(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	protoService *descriptorpb.ServiceDescriptorProto,
) {
	names := newNames(service)
	generateServerInterface(g, service, names)
	generateServerImplementation(g, file, service, protoService, names)
}

func generateServerInterface(g *protogen.GeneratedFile, service *protogen.Service, names names) {
	g.Annotate(names.Server, service.Location)
	g.P("type ", names.Server, " interface {")
	for _, method := range service.Methods {
		g.P(generateServerInterfaceMethod(g, method))
	}
	g.P("}")
	g.P()
}

func generateServerImplementation(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	protoService *descriptorpb.ServiceDescriptorProto,
	names names,
) {
	g.P("type ", names.Handler, " struct {")
	g.P("	server ", names.Server)
	g.P("	mapping map[string]map[string]http.HandlerFunc")
	g.P("}")
	g.P()
	g.P("func (h *", names.Handler, ") ServeHTTP(w ",
		g.QualifiedGoIdent(httpPackage.Ident("ResponseWriter")), ", r *http.Request) {")
	g.P("	if methods, ok := h.mapping[r.URL.Path]; ok {")
	g.P("		if handler, ok := methods[r.Method]; ok {")
	g.P("			handler(w, r)")
	g.P("		} else {")
	g.P("			w.WriteHeader(http.StatusMethodNotAllowed)")
	g.P("		}")
	g.P("		return")
	g.P("	} else {")
	g.P("		w.WriteHeader(http.StatusNotFound)")
	g.P("	}")
	g.P("}")
	g.P()
	g.P("func New", names.Handler, "(server ", names.Server, ") *",
		names.Handler, " {")
	g.P("	h := &", names.Handler, "{")
	g.P("		mapping: make(map[string]map[string]http.HandlerFunc),")
	g.P("		server: server,")
	g.P("	}")
	g.P()
	g.P("	h.mapping = map[string]map[string]http.HandlerFunc{")
	generateServerImplementationMethods(g, file, service, protoService)
	g.P("	}")
	g.P("	return h")
	g.P("}")
	generateServerImplementationHandlers(g, file, service, names)
	g.P()
}

func generateServerInterfaceMethod(g *protogen.GeneratedFile, method *protogen.Method) string {
	return "	" + method.GoName + "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context")) +
		", req *" + g.QualifiedGoIdent(method.Input.GoIdent) +
		") (*" + g.QualifiedGoIdent(method.Output.GoIdent) + ", error)"
}

func generateServerImplementationMethods(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	protoService *descriptorpb.ServiceDescriptorProto,
) {
	paths := make(map[string]map[string]*protogen.Method)
	for i, method := range service.Methods {
		httpMethod, httpPath, err := httpOptions(protoService.Method[i])
		if err != nil {
			panic(err)
		}
		p, exists := paths[httpPath]
		if !exists {
			p = make(map[string]*protogen.Method)
		}
		p[httpMethod] = method
		paths[httpPath] = p
	}
	for path, methods := range paths {
		g.P(`		"`, path, `": map[string]http.HandlerFunc{`)
		for method, handler := range methods {
			g.P(`			"`, method, `": h.`, handler.GoName, "Handler,")
		}
		g.P("		},")
	}
}

func generateServerImplementationHandlers(
	g *protogen.GeneratedFile,
	file *protogen.File,
	service *protogen.Service,
	names names,
) {
	for _, method := range service.Methods {
		g.P("func (h *", names.Handler, ") ", method.GoName, "Handler",
			"(w http.ResponseWriter, r *http.Request) {")
		g.P("var req ", g.QualifiedGoIdent(method.Input.GoIdent))
		// TODO: Only do on non-GET requests
		g.P("if err := ", jsonPackage.Ident("NewDecoder"), "(r.Body).Decode(&req); err != nil {")
		g.P("	w.WriteHeader(http.StatusBadRequest)")
		g.P(`	fmt.Fprintf(w, "unable to parse JSON: %s", err.Error())`)
		g.P("	return")
		g.P("}")
		g.P("defer r.Body.Close()")
		g.P("resp, err := h.server.", method.GoName, "(r.Context(), &req)")
		g.P("if err != nil {")
		// TODO: Handle gRPC status codes
		g.P("	w.WriteHeader(http.StatusInternalServerError)")
		g.P("	", fmtPackage.Ident("Fprintf"), `(w, "unable to serve: %s", err.Error())`)
		g.P("	return")
		g.P("}")
		g.P("w.WriteHeader(http.StatusOK)")
		g.P("_ = json.NewEncoder(w).Encode(resp)")
		g.P("}")
		g.P()
	}
}

type names struct {
	Base                string
	Client              string
	ClientConstructor   string
	ClientImpl          string
	ClientExposeMethod  string
	Server              string
	Handler             string
	ServerConstructor   string
	UnimplementedServer string
}

func newNames(service *protogen.Service) names {
	base := service.GoName
	return names{
		Base:                base,
		Client:              fmt.Sprintf("%sClient", base),
		ClientConstructor:   fmt.Sprintf("New%sClient", base),
		ClientImpl:          fmt.Sprintf("%sClient", unexport(base)),
		Server:              fmt.Sprintf("%sServer", base),
		Handler:             fmt.Sprintf("%sHandler", base),
		ServerConstructor:   fmt.Sprintf("New%sServer", base),
		UnimplementedServer: fmt.Sprintf("Unimplemented%sServer", base),
	}
}

func unexport(s string) string {
	return strings.ToLower(s[:1]) + s[1:]
}

func httpOptions(method *descriptorpb.MethodDescriptorProto) (string, string, error) {
	if method.Options == nil {
		return "", "", nil
	}

	if !proto.HasExtension(method.Options, options.E_Http) {
		return "", "", nil
	}
	ext := proto.GetExtension(method.Options, options.E_Http)
	opts, ok := ext.(*options.HttpRule)
	if !ok {
		return "", "", fmt.Errorf("extention is %T, want HttpRule", ext)
	}
	var httpMethod, httpPath string
	switch opts.Pattern.(type) {
	case *options.HttpRule_Get:
		httpMethod = http.MethodGet
		httpPath = opts.GetGet()
	case *options.HttpRule_Put:
		httpMethod = http.MethodPut
		httpPath = opts.GetPut()
	case *options.HttpRule_Post:
		httpMethod = http.MethodPost
		httpPath = opts.GetPost()
	case *options.HttpRule_Delete:
		httpMethod = http.MethodDelete
		httpPath = opts.GetDelete()
	case *options.HttpRule_Patch:
		httpMethod = http.MethodPatch
		httpPath = opts.GetPatch()
	case *options.HttpRule_Custom:
		httpMethod = opts.GetCustom().Kind
		httpPath = opts.GetCustom().Path
	}
	return httpMethod, httpPath, nil
}
